{"version":3,"sources":["api/index.js","components/Feature.js","components/Loading.js","components/Preview.js","components/Search.js","components/Title.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromTermAndValue","term","value","a","fetch","encodeURI","split","join","response","json","data","fetchQueryResultsFromURL","url","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Searchable","props","searchTerm","searchValue","setIsLoading","setSearchResults","className","href","onClick","event","preventDefault","results","console","error","Feature","featuredResult","id","title","dated","images","description","primaryimageurl","culture","style","technique","medium","dimensions","people","department","division","contact","creditline","toLowerCase","map","person","displayname","image","src","alt","Loading","Preview","setFeaturedResult","searchResults","info","fetchPage","pageUrl","disabled","prev","next","record","index","key","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","centuries","classifications","onSubmit","htmlFor","type","placeholder","onChange","target","length","name","Title","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"oMAKaA,EAAW,oCACXC,EAAM,8CAKZ,SAAeC,EAAtB,oC,4CAAO,WAAiDC,EAAMC,GAAvD,iBAAAC,EAAA,+EAEoBC,MAAM,GAAD,OAAKN,EAAL,mBAA0BC,EAA1B,YAAmCE,EAAnC,YAA6CI,UAAUH,EAAMI,MAAM,KAAKC,KAAK,QAFtG,cAEGC,EAFH,gBAGgBA,EAASC,OAHzB,cAGGC,EAHH,yBAKIA,GALJ,wG,sBAcA,SAAeC,EAAtB,kC,4CAAO,WAAwCC,GAAxC,iBAAAT,EAAA,+EAEoBC,MAAMQ,GAF1B,cAEGJ,EAFH,gBAGgBA,EAASC,OAHzB,cAGGC,EAHH,yBAKIA,GALJ,wG,sBAgBA,SAAeG,EAAtB,kC,4CAAO,uCAAAV,EAAA,6DACLW,EADK,EACLA,QACAC,EAFK,EAELA,eACAC,EAHK,EAGLA,YAEMJ,EALD,UAKWd,EALX,mBAKgCC,EALhC,2BAKwDgB,EALxD,oBAMHD,EANG,oBAMkBE,GANlB,kBASoBZ,MAAMQ,GAT1B,cASGJ,EATH,gBAUgBA,EAASC,OAVzB,cAUGC,EAVH,yBAYIA,GAZJ,wG,sBAqBA,SAAeO,IAAtB,+B,4CAAO,kCAAAd,EAAA,0DACDe,aAAaC,QAAQ,aADpB,yCAEIC,KAAKC,MAAMH,aAAaC,QAAQ,eAFpC,cAKCP,EALD,UAKWd,EALX,oBAKiCC,EALjC,kDAQoBK,MAAMQ,GAR1B,cAQGJ,EARH,gBASgBA,EAASC,OATzB,cASGC,EATH,OAUGY,EAAUZ,EAAKY,QAErBJ,aAAaK,QAAQ,YAAaH,KAAKI,UAAUF,IAZ9C,kBAcIA,GAdJ,wG,sBAuBA,SAAeG,IAAtB,+B,4CAAO,kCAAAtB,EAAA,0DACDe,aAAaC,QAAQ,mBADpB,yCAEIC,KAAKC,MAAMH,aAAaC,QAAQ,qBAFpC,cAKCP,EALD,UAKWd,EALX,2BAKwCC,EALxC,yCAQoBK,MAAMQ,GAR1B,cAQGJ,EARH,gBASgBA,EAASC,OATzB,cASGC,EATH,OAUGY,EAAUZ,EAAKY,QAErBJ,aAAaK,QAAQ,kBAAmBH,KAAKI,UAAUF,IAZpD,kBAcIA,GAdJ,wG,sBCtDP,IAAMI,EAAa,SAACC,GAAW,IACpBC,EAA2DD,EAA3DC,WAAYC,EAA+CF,EAA/CE,YAAaC,EAAkCH,EAAlCG,aAAcC,EAAoBJ,EAApBI,iBAC9C,OACI,0BAAMC,UAAU,WAChB,uBAAGC,KAAK,IAAIC,QAAO,uCAAE,WAAOC,GAAP,eAAAhC,EAAA,6DACjBgC,EAAMC,iBACNN,GAAa,GAFI,kBAKS9B,EAAmC4B,EAAYC,GALxD,OAKPQ,EALO,OAMbN,EAAiBM,GANJ,gDAQbC,QAAQC,MAAR,MARa,yBAUbT,GAAa,GAVA,4EAAF,uDAAnB,gBA+JOU,EA5GC,SAACb,GAAW,IACjBc,EAAkBd,EAAlBc,eACP,IAAIA,EACJ,OAAO,0BAAMC,GAAG,YAHO,IAMnBC,EAgBEF,EAhBFE,MACAC,EAeEH,EAfFG,MACAC,EAcEJ,EAdFI,OAEAC,GAYEL,EAbFM,gBAaEN,EAZFK,aACAE,EAWEP,EAXFO,QACAC,EAUER,EAVFQ,MACAC,EASET,EATFS,UACAC,EAQEV,EARFU,OACAC,EAOEX,EAPFW,WACAC,EAMEZ,EANFY,OACAC,EAKEb,EALFa,WACAC,EAIEd,EAJFc,SACAC,EAGEf,EAHFe,QACAC,EAEEhB,EAFFgB,WAIJ,OACA,0BAAMf,GAAG,WACT,yBAAKV,UAAU,kBACb,gCACE,4BAAKW,GACL,4BAAKC,IAEP,6BAASZ,UAAU,SACdc,EACD,kBAAC,WAAD,KACE,0BAAMd,UAAU,SAAhB,eACA,0BAAMA,UAAU,WAAWc,IAE3B,KACDE,EACD,kBAAC,WAAD,KACE,0BAAMhB,UAAU,SAAhB,WACA,0BAAMA,UAAU,WAAU,kBAAC,EAAD,eAAYJ,WAAY,UAAUC,YAAamB,GAAarB,MAEpF,KACDsB,EACH,kBAAC,WAAD,KACE,0BAAMjB,UAAU,SAAhB,SACA,0BAAMA,UAAU,WAAWiB,IAE3B,KACDC,EACD,kBAAC,WAAD,KACE,0BAAMlB,UAAU,SAAhB,aACA,0BAAMA,UAAU,WAAU,kBAAC,EAAD,eAAYJ,WAAa,YAAYC,YAAeqB,GAAevB,IAA7F,MAEA,KACDwB,EACD,kBAAC,WAAD,KACE,0BAAMnB,UAAU,SAAhB,UACA,0BAAMA,UAAU,WAAhB,IAA2B,kBAAC,EAAD,eAAYJ,WAAa,SAASC,YAAesB,EAAOO,eAAmB/B,IAAtG,MAEA,KACDyB,EACD,kBAAC,WAAD,KACE,0BAAMpB,UAAU,SAAhB,cACA,0BAAMA,UAAU,WAAWoB,IAE3B,KACDC,EACD,kBAAC,WAAD,KACI,0BAAMrB,UAAW,SAAjB,YACA,0BAAMA,UAAU,WAAhB,IAA4BqB,EAAOM,KAAK,SAAAC,GAAM,OAAI,kBAAC,EAAD,eAAYhC,WAAa,SAASC,YAAe+B,EAAOC,aAAiBlC,OAA3H,MACO,KACT2B,EACF,kBAAC,WAAD,KACE,0BAAMtB,UAAU,SAAhB,cACA,0BAAMA,UAAU,WAAWsB,IAE3B,KACDC,EACD,kBAAC,WAAD,KACE,0BAAMvB,UAAU,SAAhB,YACA,0BAAMA,UAAU,WAAWuB,IAE3B,KACDC,EACD,kBAAC,WAAD,KACE,0BAAMxB,UAAU,SAAhB,WACA,0BAAMA,UAAU,WAAWwB,IAE1B,KACDC,EACF,kBAAC,WAAD,KACE,0BAAMzB,UAAU,SAAhB,cACA,0BAAMA,UAAU,WAAWyB,IAE3B,MAEA,6BAASzB,UAAU,UACvBa,EAASA,EAAOc,KAAI,SAACG,GACjB,OACJ,yBAAKC,IAAKD,EAAMf,gBAAiBiB,IAAKF,EAAMf,qBAEzC,SC7KIkB,EAPC,WACZ,OACI,yBAAKvB,GAAG,WACJ,wBAAIV,UAAU,WAAd,kBC+EGkC,EAnFC,SAACvC,GAAW,IACnBI,EAAqDJ,EAArDI,iBAAkBoC,EAAmCxC,EAAnCwC,kBAAmBrC,EAAgBH,EAAhBG,aADnB,EAGDH,EAAMyC,cAAvBC,EAHkB,EAGlBA,KAAM/C,EAHY,EAGZA,QAHY,SAkBVgD,EAlBU,8EAkBzB,WAAyBC,GAAzB,eAAApE,EAAA,6DACE2B,GAAa,GADf,kBAI0BnB,EAAyB4D,GAJnD,OAIUlC,EAJV,OAKIN,EAAiBM,GALrB,gDAOIC,QAAQC,MAAR,MAPJ,yBASIT,GAAa,GATjB,6EAlByB,sBA8BzB,OAAO,2BAAOY,GAAG,WACf,4BAAQV,UAAU,cAEhB,4BACEwC,UAAWH,EAAKI,KAChBzC,UAAU,WACVE,QAAS,kBAAMoC,EAAUD,EAAKI,QAHhC,YAKA,4BACED,UAAWH,EAAKK,KAChB1C,UAAU,OACVE,QAAS,kBAAMoC,EAAUD,EAAKK,QAHhC,SAuBG,6BAAS1C,UAAU,WAAWV,EAAQqC,KAAI,SAACgB,EAAQC,GAAT,OAG1C,yBACAC,IAAMD,EACN5C,UAAU,iBACVE,QAAS,SAACC,GACTA,EAAMC,iBACN+B,EAAkBQ,KAElBA,EAAO5B,gBAAkB,yBAAKgB,IAAMY,EAAO5B,gBAAkBiB,IAAMW,EAAO7B,cAAmB,KAC7F6B,EAAOhC,MAAQ,4BAAMgC,EAAOhC,OAAe,4CAR5C,WC6DMmC,EA1HA,SAACnD,GAAU,IAEjBG,EAAkCH,EAAlCG,aAAcC,EAAoBJ,EAApBI,iBAFG,EAecgD,mBAAS,IAfvB,mBAejBC,EAfiB,KAeJC,EAfI,OAgB4BF,mBAAS,IAhBrC,mBAgBjBG,EAhBiB,KAgBGC,EAhBH,OAiBcJ,mBAAS,IAjBvB,mBAiBjB/D,EAjBiB,KAiBJoE,EAjBI,OAkBML,mBAAS,OAlBf,mBAkBjBjE,EAlBiB,KAkBRuE,EAlBQ,OAmBoBN,mBAAS,OAnB7B,mBAmBjBhE,EAnBiB,KAmBDuE,EAnBC,KA0DxB,OA9BAC,qBAAU,WACR,IACAC,QAAQC,IAAI,CAACxE,IAAqBQ,MAEjCiE,MAAK,YAAkC,IAAD,mBAA/BC,EAA+B,KAArBC,EAAqB,KACrCX,EAAeU,GACfR,EAAsBS,MAGxB,MAAOrD,GACPD,QAAQC,MAAMA,MAGb,IAiBI,0BAAMG,GAAG,SAASmD,SAAQ,uCAAE,WAAO1D,GAAP,eAAAhC,EAAA,6DAE/BgC,EAAMC,iBACNN,GAAa,GAHkB,kBAMPjB,EAAkB,CACtCC,UACAC,iBACAC,gBAT2B,OAMvBqB,EANuB,OAW7BN,EAAiBM,GAXY,gDAa7BC,QAAQC,MAAR,MAb6B,yBAe7BT,GAAa,GAfgB,4EAAF,uDAkB/B,kCACE,2BAAOgE,QAAQ,YAAf,SACA,2BACEpD,GAAG,WACHqD,KAAK,OACLC,YAAY,oBACZ9F,MAA4Cc,EAC5CiF,SAAgE,SAAC9D,GAC/DiD,EAAejD,EAAM+D,OAAOhG,WAKlC,kCACE,2BAAO4F,QAAQ,yBAAf,kBAAsD,0BAAM9D,UAAU,wBAAhB,IAA0CkD,EAAmBiB,OAA7D,MACtD,4BACEC,KAAK,iBACL1D,GAAG,wBACHxC,MAA8Ca,EAC9CkF,SAAkE,SAAC9D,GACjEmD,EAAkBnD,EAAM+D,OAAOhG,SAEjC,4BAAQA,MAAM,OAAd,OAC4DgF,EAAmBvB,KAAI,YAAkB,IAAhByC,EAAe,EAAfA,KAAKxB,EAAU,EAAVA,MACvF,OAAO,4BAAQ1E,MAAQkG,EAAMvB,IAAKD,GAAQwB,QAIjD,kCACE,2BAAON,QAAQ,kBAAf,WAAwC,0BAAM9D,UAAU,iBAAhB,IAAmCgD,EAAYmB,OAA/C,MACxC,4BACEC,KAAK,UACL1D,GAAG,iBACHxC,MAAuCY,EACvCmF,SAA2D,SAAC9D,GAC1DkD,EAAWlD,EAAM+D,OAAOhG,SAC1B,4BAAQA,MAAM,OAAd,OACqD8E,EAAYrB,KAAI,YAAmB,IAAjByC,EAAgB,EAAhBA,KAAMxB,EAAU,EAAVA,MAC3E,OAAO,4BAAQ1E,MAAOkG,EAAMvB,IAAKD,GAAQwB,QAI/C,4CCvGWC,EAZD,WACV,OACA,yBAAK3D,GAAG,SACT,iDAGA,qFCRG4D,EAAM,WAAM,MAS0BvB,mBAAS,CAACV,KAAK,GAAI/C,QAAQ,KATrD,mBAST8C,EATS,KASMrC,EATN,OAU4BgD,mBAAS,MAVrC,mBAUTtC,EAVS,KAUO0B,EAVP,OAWkBY,oBAAS,GAX3B,mBAWTwB,EAXS,KAWEzE,EAXF,KAahB,OAAO,yBAAKE,UAAU,OAEpB,kBAAC,EAAD,MAEA,kBAAC,EAAD,CAAQF,aAAeA,EAAcC,iBAAkBA,IAEvD,kBAAC,EAAD,CAASqC,cAAgBA,EAAetC,aAAeA,EAAcC,iBAAkBA,EAAkBoC,kBAAmBA,IAE5H,kBAAC,EAAD,CAAS1B,eAAkBA,EAAgBX,aAAeA,EAAcC,iBAAkBA,IAEzFwE,EAAW,kBAAC,EAAD,MAAc,OAQ9BC,IAASC,OACP,kBAAC,EAAD,MACAC,SAASC,eAAe,S","file":"static/js/main.766f4dcd.chunk.js","sourcesContent":["/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=b0a3fe9e-b791-4f7d-81f0-62ad53cf8386';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}","import React, { Fragment } from 'react';\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n\n/**\n * We need a new component called Searchable which:\n * \n * Has a template like this:\n * \n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n * \n * When someone clicks the anchor tag, you should:\n * \n * - preventDefault on the event\n * - call setIsLoading, set it to true\n * \n * Then start a try/catch/finally block:\n * \n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch: \n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = (props) => {\n    const {searchTerm, searchValue, setIsLoading, setSearchResults} = props\n    return(\n        <span className=\"content\">\n        <a href=\"#\" onClick={async (event) => {\n            event.preventDefault()\n            setIsLoading(true)\n\n            try {\n                const results = await fetchQueryResultsFromTermAndValue( searchTerm, searchValue)\n                setSearchResults(results)\n            } catch (error) {\n                console.error(error);\n              } finally {\n                setIsLoading(false);\n            }\n        }}>searchTerm</a>\n        </span>\n    ) \n}\n\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n * \n * <main id=\"feature\"></main>\n * \n * And like this when one is:\n * \n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n * \n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n * technique, medium, dimensions, people, department, division, contact, creditline\n * \n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n * \n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n * \n * This component should be exported as default.\n */\nconst Feature = (props) => {\n    const {featuredResult} = props\n    if(!featuredResult){\n    return <main id=\"feature\"></main>\n    }\n    const {\n        title, \n        dated, \n        images, \n        primaryimageurl, \n        description, \n        culture, \n        style,\n        technique, \n        medium, \n        dimensions, \n        people, \n        department, \n        division, \n        contact, \n        creditline\n  \n      } = featuredResult;\n\n    return (\n    <main id=\"feature\">\n    <div className=\"object-feature\">\n      <header>\n        <h3>{title}</h3>\n        <h4>{dated}</h4>\n      </header>\n      <section className=\"facts\">\n          {description ? (\n          <Fragment>\n            <span className=\"title\">Description</span>\n            <span className=\"content\">{description}</span>\n          </Fragment>\n          ):null}\n          {culture ? (\n          <Fragment>\n            <span className=\"title\">Culture</span>\n            <span className=\"content\"><Searchable searchTerm ='culture' searchValue={culture} {...props} /></span>\n          </Fragment>\n            ):null}\n            {style ?(\n          <Fragment>\n            <span className=\"title\">Style</span>\n            <span className=\"content\">{style}</span>\n          </Fragment>\n          ):null}\n          {technique ?(\n          <Fragment>\n            <span className=\"title\">Technique</span>\n            <span className=\"content\"><Searchable searchTerm = 'technique' searchValue = {technique} {...props} /> </span>\n          </Fragment>\n          ):null}\n          {medium ?(\n          <Fragment>\n            <span className=\"title\">Medium</span>\n            <span className=\"content\"> <Searchable searchTerm = 'medium' searchValue = {medium.toLowerCase()} {...props} /> </span>\n          </Fragment>\n          ):null}\n          {dimensions ?(\n          <Fragment>\n            <span className=\"title\">Dimensions</span>\n            <span className=\"content\">{dimensions}</span>\n          </Fragment>\n          ):null}\n          {people ?(\n          <Fragment> \n              <span className ='title'> People </span> \n              <span className='content'> {people.map (person => <Searchable searchTerm = 'person' searchValue = {person.displayname} {...props} />)} </span> \n      </Fragment> ): null}\n           {department ?(\n          <Fragment>\n            <span className=\"title\">Department</span>\n            <span className=\"content\">{department}</span>\n          </Fragment>\n          ):null}\n          {division ?(\n          <Fragment>\n            <span className=\"title\">Division</span>\n            <span className=\"content\">{division}</span>\n          </Fragment>\n          ):null}\n          {contact ?(\n          <Fragment>\n            <span className=\"title\">Contact</span>\n            <span className=\"content\">{contact}</span>\n          </Fragment>\n           ):null}\n           {creditline ?(\n          <Fragment>\n            <span className=\"title\">Creditline</span>\n            <span className=\"content\">{creditline}</span>\n          </Fragment>\n          ):null}\n        </section>\n            <section className=\"photos\">\n       {images ? images.map((image) => {\n            return (\n        <img src={image.primaryimageurl} alt={image.primaryimageurl} />\n       )\n        }):null}\n      </section>\n    </div>\n    </main>           \n    )}\nexport default Feature;","import React from 'react';\n\n/**\n * Create and export a component called Loading which uses this static HTML template:\n * \n * <div id=\"loading\">\n *   <h2 className=\"message\">Searching...</h2>\n * </div>\n */\nconst Loading = () =>{\n    return (\n        <div id=\"loading\">\n            <h2 className=\"message\">Searching...</h2>\n        </div>\n    )\n}\nexport default Loading\n","import React from 'react';\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from '../api';\n\nconst Preview = (props) => {\n  const {setSearchResults, setFeaturedResult, setIsLoading} = props;\n\n  const {info, records} = props.searchResults\n\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   * \n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n\n\n  /**\n   * Don't touch this function, it's good to go.\n   * \n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n  return <aside id=\"preview\">\n    <header className=\"pagination\">\n      {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n      <button \n        disabled={!info.prev} \n        className=\"previous\"\n        onClick={() => fetchPage(info.prev)}>Previous</button>\n      {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n      <button\n        disabled={!info.next}\n        className=\"next\"\n        onClick={() => fetchPage(info.next)}>Next</button>\n    </header>\n  \n      {\n        /* Here we should map over the records, and render something like this for each one:\n          <div  \n            key={ index }\n            className=\"object-preview\"\n            onClick={(event) => {\n              // prevent the default\n              // set the featured result to be this record, using setFeaturedResult\n            }}>\n            { \n              // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing \n            }\n            {\n              // if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n            }\n          </div>\n          */}\n         <section className=\"results\">{records.map((record, index) => \n        //  return (\n        \n         <div  \n         key={ index }\n         className=\"object-preview\"\n         onClick={(event) => {\n          event.preventDefault();\n          setFeaturedResult(record)\n       }}>\n         {record.primaryimageurl ? <img src={ record.primaryimageurl } alt={ record.description } /> : null}\n         {record.title ? <h3>{ record.title }</h3> : <h3>MISSING INFO</h3>};\n      \n         </div>\n        //  )\n      \n         )}\n  \n    </section>\n  </aside> \n  }\n\nexport default Preview;\n\n","import React, { useEffect, useState } from 'react';\n\n/**\n * Don't touch these imports!\n */\nimport { \n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\nconst Search = (props) => {\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n  const {setIsLoading, setSearchResults} = props;\n\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * \n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n  const [centuryList, setCenturyList] = useState([]);\n  const [classificationList, setClassificationList] = useState([]);\n  const [queryString, setQueryString] = useState('');\n  const [century, setCentury] = useState('any')\n  const [classification, setClassification] = useState('any')\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * \n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * \n   * Make sure to console.error on caught errors from the API methods.\n   */\n  useEffect(() => {\n    try{\n    Promise.all([fetchAllCenturies(), fetchAllClassifications()])\n\n    .then(([centuries,classifications]) => {\n      setCenturyList(centuries);\n      setClassificationList(classifications);\n    }\n    );\n  } catch (error){\n    console.error(error);\n  \n  }\n  }, []);\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * \n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * \n   * then, in a try/catch/finally block:\n   * \n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   * \n   * catch: error to console.error\n   * \n   * finally: call setIsLoading, set it to false\n   */\n  return <form id=\"search\" onSubmit={async (event) => {\n    // write code here\n      event.preventDefault();\n      setIsLoading(true);\n\n      try {\n        const results = await fetchQueryResults({\n          century,\n          classification,\n          queryString,\n        });\n        setSearchResults(results)\n      }catch(error){\n        console.error(error)\n      }finally{\n        setIsLoading(false)\n      }\n  }}>\n    <fieldset>\n      <label htmlFor=\"keywords\">Query</label>\n      <input \n        id=\"keywords\" \n        type=\"text\" \n        placeholder=\"enter keywords...\" \n        value={/* this should be the query string */queryString} \n        onChange={/* this should update the value of the query string */(event) => {\n          setQueryString(event.target.value);\n        }}\n        />\n\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({ classificationList.length })</span></label>\n      <select \n        name=\"classification\"\n        id=\"select-classification\"\n        value={/* this should be the classification */classification} \n        onChange={/* this should update the value of the classification */(event) =>{\n          setClassification(event.target.value)\n        }}>\n        <option value=\"any\">Any</option>\n        {/* map over the classificationList, return an <option /> */classificationList.map(({name,index}) =>{\n           return <option value= {name} key={index}>{name}</option>\n        })}\n      </select>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-century\">Century <span className=\"century-count\">({ centuryList.length })</span></label>\n      <select \n        name=\"century\" \n        id=\"select-century\"\n        value={/* this should be the century */century} \n        onChange={/* this should update the value of the century */(event) =>{\n          setCentury(event.target.value)} }>\n        <option value=\"any\">Any</option>\n        {/* map over the centuryList, return an <option /> */centuryList.map(({name, index}) =>{\n          return <option value={name} key={index}>{name}</option>\n        })}\n      </select>\n     </fieldset>\n    <button>SEARCH</button>\n  </form>\n}\n\nexport default Search;","import React from 'react';\n\n/**\n * Create/export a component called Title which uses this static HTML as the template:\n * \n * <div id=\"title\">\n *   <h1>\n *     The Art Collector\n *   </h1>\n *   <h5>\n *     Search the Harvard Art Museums' Private Collections\n *   </h5>\n * </div>\n */\nconst Title = () =>{\n    return (\n    <div id=\"title\">\n   <h1>\n      The Art Collector\n   </h1>\n   <h5>\n      Search the Harvard Art Museums' Private Collections\n   </h5>\n</div>\n);\n};\nexport default Title;\n","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// These imports won't work until you fix ./components/index.js\nimport {\n  Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n} from './components';\n\nconst App = () => {\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n  const [searchResults, setSearchResults] = useState({info:{}, records:[]})\n  const [featuredResult, setFeaturedResult] = useState(null)\n  const [isLoading, setIsLoading] = useState(false)\n\n  return <div className=\"app\">\n    {/* <Title /> is static, doesn't need any props */}\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    <Search setIsLoading ={setIsLoading} setSearchResults={setSearchResults}/>\n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    <Preview searchResults ={searchResults} setIsLoading ={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult}/>\n    {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n    <Feature featuredResult = {featuredResult} setIsLoading ={setIsLoading} setSearchResults={setSearchResults}/>\n    {/* <Loading /> is static, but should only render when isLoading is true */}\n    {isLoading ?<Loading /> : null}{/* use a ternary and render null if isLoading is false */}\n  </div>\n}\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */\nReactDOM.render(\n  <App />,\n  document.getElementById('app')\n);"],"sourceRoot":""}